"""
@file       pv_interface.py
@author     Matthew Yu (matthewjkyu@gmail.com)
@brief      Interface for any PV.
@version    0.4.0
@date       2023-09-24
"""
import sys

sys.path.extend([".", "..", "../.."])


import math as m
import numpy as np
import pandas as pd
from PySide6 import QtWidgets
from common.graph import Graph
from environment.environment import Environment
from lmfit import Parameters, fit_report, minimize


class PVInterface:
    def __init__(self, env: Environment, params: dict, data_fp=None) -> None:
        """Create a PVInterface instance.

        Args:
            env (Environment): External PV environment.
            params (dict): Internal PV characteristics.
            data_fp (str, optional): Path to a file rrepresenting experimental
            data of the PV. Defaults to None.
        """
        self._env = env
        self._params = params
        self._data = None
        if data_fp is not None:
            self._data = self.load_data(data_fp)

    def get_pos(self) -> (int, int):
        """Get the position of the PV constituents.

        Returns:
            [(int, int)]: List of cell positions in PV.
        """
        raise NotImplementedError

    def get_voltage(self, current: float, root_pos: (int, int, int)) -> float:
        """Get the voltage generated by the PV as a function of the current
        applied across the PV and external environment and internal cell
        characteristics.

        Args:
            current (float): Current across PV. Amps.
            root_pos (int, int, int): X, Y, T point of the PV.

        Returns:
            float: Voltage from PV. Volts.
        """
        raise NotImplementedError

    def get_iv(self, root_pos: (int, int, int)) -> [(float, float, float)]:
        """Get the I-V curve of the instance for some specific irradiance and
        temperature as an array of points spaced by SAMPLE_RES.

        TODO: support quadrant 2, quadrant 4 I-V output

        Args:
            root_pos (int, int, int): X, Y, T point of the PV.

        Returns:
            [(float, float, float)]: List of voltage-current-power pairs.
            Ordered.
        """
        iv = []

        curr = 0.0
        res = 0.1
        loop = 0
        num_loops = 4
        while loop < num_loops:
            # Increment resolution decreases by (0.05)^n
            curr += res
            volt = self.get_voltage(curr, root_pos)
            iv.append((volt, curr, volt * curr))
            if volt == 0.0:
                # https://www.desmos.com/calculator/mffm3b9ucm
                # Set x=num_loops and adjust a, b, z to meet requirements
                # - z: I_SC of typical cell
                # - a: Starting proportion of Z, set to right side of knee of
                #   typical I-V curve
                # - b: Adjust such that at X=num_loops the curve is barely under
                #   it (<0.1).
                new_curr = curr * (0.75 + m.log(loop + 1) * 0.175)
                res = res / 5
                curr = new_curr
                loop += 1

        # Generate an interolation function to fill in the blanks.
        # volt, curr, pow = np.transpose(iv)
        # f_interp = scipy_interp1d(volt, curr, kind="slinear")
        # volts = np.linspace(np.min(volt), np.max(volt), num=100)
        # curr = f_interp(volts)
        # pow = volts * curr
        # iv.extend(np.transpose([volts, curr, pow]))
        iv.sort(key=lambda item: item[0])

        return iv

    def get_edge(self, root_pos: (int, int, int)) -> ((float, float), (float, float)):
        """Get the 1st power quadrant edge characteristics of the instance.

        Args:
            root_pos (int, int, int): X, Y, T point of the PV.

        Returns:
            (float, float), (float, float):
                Open circuit voltage (Volts)
                Short circuit current (Amps)
                Maximum power point voltage (Volts)
                Maximum power point current (Amps)
        """
        iv = self.get_iv(root_pos)
        df = pd.DataFrame(iv, columns=["Voltage (V)", "Current (A)", "Power (W)"])

        v_oc = df.nlargest(1, "Voltage (V)").iloc[0]["Voltage (V)"]
        i_sc = df.nlargest(1, "Current (A)").iloc[0]["Current (A)"]

        mpp = df.nlargest(1, "Power (W)")
        v_mpp = mpp.iloc[0]["Voltage (V)"]
        i_mpp = mpp.iloc[0]["Current (A)"]

        return (v_oc, i_sc), (v_mpp, i_mpp)

    def get_parameters(self) -> dict:
        """Get associated reference and curve fitting parameters associated with
        the PV.

        Returns:
            dict: Parameters.
        """
        return self._params

    def load_data(self, data_fp: str) -> pd.DataFrame:
        """Load data from source associated with the model.

        Args:
            data_fp (str): Path to file to load.

        Returns:
            pd.DataFrame: Dataframe of points from the data source.
        """
        raise NotImplementedError

    def _normalize_data(self, data) -> None:
        # TODO: normalization function for data.
        raise NotImplementedError

    def _set_params_and_fit(self, data, fitting_parameters, residual):
        """Fit model to the data and update the associated parameters.
        TODO: this.

        Args:
            data (_type_): _description_
            fitting_parameters (_type_): _description_
            residual (_type_): _description_

        Returns:
            _type_: _description_
        """
        optimizer_parameters = Parameters()
        for key, value in fitting_parameters.items():
            if value["given"]:
                optimizer_parameters.add(
                    key,
                    min=value["min"] * 1e-7,
                    value=value["val"] * 1e-7,
                    max=value["max"] * 1e-7,
                    vary=False,
                )
            else:
                optimizer_parameters.add(
                    key,
                    min=value["min"] * 1e-7,
                    value=value["stc"] * 1e-7,
                    max=value["max"] * 1e-7,
                    vary=True,
                )

        res = minimize(
            residual,
            optimizer_parameters,
            args=(data, self),
            method="powell",
        )
        print(fit_report(res))

        for key, value in fitting_parameters.items():
            value["val"] = res.params[key].value * 1e7

        return fitting_parameters

    def fit_parameters(
        self, irradiance: float = None, temperature: float = None
    ) -> dict:
        """Fit parameters relevant to the model and return their results.

        Args:
            irradiance (float, optional): Known irradiance if any. Defaults to None.
            temperature (float, optional): Known temperature if any. Defaults to None.

        Returns:
            dict: Dict of fitting parameters and determined values.
        """
        raise NotImplementedError

    def vis(self, root_pos: ([int, int, int])) -> None:
        """
        TODO: documentation, support for:
        - displaying experimental data
        - returning a widget
        - specifying a sweep across a set of external or internal parameters.
        - specifying multiple graphs
        - specifying bounds
        """

        if not QtWidgets.QApplication.instance():
            app = QtWidgets.QApplication(sys.argv)
        else:
            app = QtWidgets.QApplication.instance()

        container = QtWidgets.QWidget()
        container_layout = QtWidgets.QGridLayout()
        container.setLayout(container_layout)

        # Create graphs
        data = self.get_iv(root_pos[0])
        data = np.transpose(data)

        # Populate graph
        graph = {
            "instance": Graph(
                "I-V/P-V Curve",
                "Voltage (V)",
                "Current (A)",
            ),
            "title": "I-V/P-V Curve",
            "widget": None,
            "position": [0, 0],
        }
        graph["instance"].add_series(
            {
                "iv": {"x": data[0], "y": data[1], "color": (255, 0, 0, 255)},
                "pv": {"x": data[0], "y": data[2], "color": (0, 255, 0, 255)},
            },
            "line",
        )
        graph["widget"] = graph["instance"].get_graph()
        # graph["instance"].set_graph_range([0, 0.8], [0, 6.5])

        container_layout.addWidget(graph["widget"], *graph["position"])

        win = QtWidgets.QMainWindow()
        win.setGeometry(0, 0, 720, 480)
        win.setWindowTitle(f"I-V/P-V Curve")
        win.setCentralWidget(container)

        win.show()
        exe = app.exec()
