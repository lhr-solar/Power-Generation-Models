"""
@file       PV.py
@author     Matthew Yu (matthewjkyu@gmail.com)
@brief      Interface for any PV.
@version    0.4.0
@date       2023-09-28
"""
import sys

sys.path.extend([".."])

import math as m

import numpy as np
import pandas as pd
from lmfit import Parameters, fit_report, minimize
from PySide6 import QtWidgets

from common.graph import Graph
from common.utils import normalize


class PV:
    def __init__(self, params: dict, data_fp=None) -> None:
        """Create a PV instance.

        Args:
            params (dict): Internal PV characteristics.
            data_fp (str, optional): Path to a file rrepresenting experimental
            data of the PV. Defaults to None.
        """
        self._params = params
        self._data = None
        if data_fp is not None:
            self._data = self.load_data(data_fp)

    def get_pos(self) -> list[list[int, int]]:
        """Get the position of the PV constituents.

        Returns:
            list[list[int, int]]: List of cell positions in PV.
        """
        raise NotImplementedError

    def get_voltage(
        self, current: float, irrad: list[float], temp: list[float]
    ) -> float:
        """Get the voltage generated by the PV as a function of the current
        applied through the PV and external environment and internal cell
        characteristics.

        Args:
            current (float): Current through PV. Amps.
            irrad (list[float]): Irradiance incident on PV. W/m^2.
            temp (list[float]): Surface temperature of PV. Kelvin.

        Returns:
            float: Voltage across PV. Volts.
        """
        raise NotImplementedError

    def get_current(
        self, voltage: float, irrad: list[float], temp: list[float]
    ) -> float:
        """Get the current generated by the PV as a function of the voltage
        applied across the PV and external environment and internal cell
        characteristics.

        Args:
            voltage (float): Voltage across PV. Volts.
            irrad (list[float]): Irradiance incident on PV. W/m^2.
            temp (list[float]): Surface temperature of PV. Kelvin.

        Returns:
            float: Current through PV. Amps.
        """
        raise NotImplementedError

    def get_iv(
        self,
        irrad: list[float],
        temp: list[float],
        curr_range: list[float] = [-10.0, 10.0],
    ) -> list[list[float, float, float]]:
        """Get the I-V curve of the instance for some specific irradiance and
        temperature as an array of points spaced by SAMPLE_RES.

        TODO: support quadrant 2, quadrant 4 I-V output

        Args:
            irrad (list[float]): Irradiance incident on PV. W/m^2.
            temp (list[float]): Surface temperature of PV. Kelvin.

        Returns:
            list[list[float, float, float]]: List of ordered
                voltage-current-power triplets. Volts, Amps, Watts.
        """
        iv = []

        curr = curr_range[0]
        bound_curr = 0.0
        res = 0.1
        loop = 0
        num_loops = 3
        while loop < num_loops:
            # Increment resolution decreases by (0.05)^n
            volt = self.get_voltage(curr, irrad, temp)
            iv.append([volt, curr, volt * curr])

            if volt < 0.0 and bound_curr == 0.0:
                # Capture Y axis boundary condition; this is where the IV curve
                # is the most flat and needs more resolution.
                bound_curr = curr

            if curr > curr_range[1]:
                # https://www.desmos.com/calculator/mffm3b9ucm
                # Set x=num_loops and adjust a, b, z to meet requirements
                # - z: I_SC of typical cell
                # - a: Starting proportion of Z, set to right side of knee of
                #   typical I-V curve
                # - b: Adjust such that at X=num_loops the curve is barely under
                #   it (<0.1).
                new_curr = bound_curr * (0.5 + m.log(loop + 1) * 0.45)
                res = res / 3
                curr = new_curr
                loop += 1

            curr += res

        # Normalize data.
        iv = normalize(np.array(iv), 100)

        return iv

    def get_edge(
        self, irrad: list[float], temp: list[float]
    ) -> ((float, float), (float, float)):
        """Get the 1st power quadrant edge characteristics of the instance.

        Args:
            irrad (list[float]): Irradiance incident on PV. W/m^2.
            temp (list[float]): Surface temperature of PV. Kelvin.

        Returns:
            (float, float), (float, float):
                Open circuit voltage (Volts)
                Short circuit current (Amps)
                Maximum power point voltage (Volts)
                Maximum power point current (Amps)
        """
        iv = self.get_iv(irrad, temp)
        df = pd.DataFrame(iv, columns=["Voltage (V)", "Current (A)", "Power (W)"])

        df = df[(df["Voltage (V)"] >= 0.0) & (df["Current (A)"] >= 0.0)]

        v_oc = df.nlargest(1, "Voltage (V)").iloc[0]["Voltage (V)"]
        i_sc = df.nlargest(1, "Current (A)").iloc[0]["Current (A)"]

        mpp = df.nlargest(1, "Power (W)")
        v_mpp = mpp.iloc[0]["Voltage (V)"]
        i_mpp = mpp.iloc[0]["Current (A)"]

        return (v_oc, i_sc), (v_mpp, i_mpp)

    def vis(
        self,
        irrad: list[float],
        temp: list[float],
        curr_range: list[float] = [-10.0, 10.0],
    ) -> None:
        """
        TODO: documentation, support for:
        - displaying experimental data
        - returning a widget
        - specifying a sweep across a set of external or internal parameters.
        - specifying multiple graphs
        - specifying bounds
        """

        if not QtWidgets.QApplication.instance():
            app = QtWidgets.QApplication(sys.argv)
        else:
            app = QtWidgets.QApplication.instance()

        container = QtWidgets.QWidget()
        container_layout = QtWidgets.QGridLayout()
        container.setLayout(container_layout)

        # Create graphs
        data = self.get_iv(irrad, temp, curr_range)
        data = np.transpose(data)

        # Populate graph
        graph = {
            "instance": Graph(
                "I-V/P-V Curve",
                "Voltage (V)",
                "Current (A)",
            ),
            "title": "I-V/P-V Curve",
            "widget": None,
            "position": [0, 0],
        }
        graph["instance"].add_series(
            {
                "iv": {"x": data[0], "y": data[1], "color": (255, 0, 0, 255)},
                "pv": {"x": data[0], "y": data[2], "color": (0, 255, 0, 255)},
            },
            "scatter",
        )
        graph["widget"] = graph["instance"].get_graph()
        # graph["instance"].set_graph_range([-0.7, 1.0], [-10, 10])

        container_layout.addWidget(graph["widget"], *graph["position"])

        win = QtWidgets.QMainWindow()
        win.setGeometry(0, 0, 720, 480)
        win.setWindowTitle(f"I-V/P-V Curve")
        win.setCentralWidget(container)

        win.show()
        exe = app.exec()

    def get_params(self) -> dict:
        """Get associated reference and curve fitting parameters associated with
        the PV.

        Returns:
            dict: Parameters.
        """
        return self._params

    def _set_params_and_fit(self, data, fitting_parameters, residual):
        """Fit model to the data and update the associated parameters.
        TODO: this.

        Args:
            data (_type_): _description_
            fitting_parameters (_type_): _description_
            residual (_type_): _description_

        Returns:
            _type_: _description_
        """
        optimizer_parameters = Parameters()
        for key, value in fitting_parameters.items():
            if value["given"]:
                optimizer_parameters.add(
                    key,
                    min=value["min"] * 1e-7,
                    value=value["val"] * 1e-7,
                    max=value["max"] * 1e-7,
                    vary=False,
                )
            else:
                optimizer_parameters.add(
                    key,
                    min=value["min"] * 1e-7,
                    value=value["stc"] * 1e-7,
                    max=value["max"] * 1e-7,
                    vary=True,
                )

        res = minimize(
            residual,
            optimizer_parameters,
            args=(data, self),
            method="powell",
        )
        print(fit_report(res))

        for key, value in fitting_parameters.items():
            value["val"] = res.params[key].value * 1e7

        return fitting_parameters

    def fit_params(self, irradiance: float = None, temperature: float = None) -> dict:
        """Fit parameters relevant to the model and return their results.

        Args:
            irradiance (float, optional): Known irradiance if any. Defaults to None.
            temperature (float, optional): Known temperature if any. Defaults to None.

        Returns:
            dict: Dict of fitting parameters and determined values.
        """
        raise NotImplementedError
