"""
@file       PV.py
@author     Matthew Yu (matthewjkyu@gmail.com)
@brief      Interface for any PV.
@version    0.4.0
@date       2023-09-28
"""
import sys

sys.path.extend([".."])

import numpy as np
import pandas as pd
from lmfit import Parameters, fit_report, minimize
from PySide6 import QtWidgets

from common.graph import Graph


class PV:
    FIT_RESOLUTION = 1e7
    IV_POINTS = 250
    IV_NORM_POINTS = 1000

    def __init__(self, params: dict, data_fp=None) -> None:
        """Create a PV instance.

        Args:
            params (dict): Internal PV characteristics.
            data_fp (str, optional): Path to a file rrepresenting experimental
            data of the PV. Defaults to None.
        """
        self._params = params
        self._data = None
        if data_fp is not None:
            self._data = self.load_data(data_fp)

    def load_data(self, data_fp: str) -> list[list[float, float, float]]:
        """Load data file associated with the system.

        Returns:
            [[float, float, float]]: List of voltage, current, power pairs.
        """
        df = pd.read_csv(data_fp, header=9)
        if "Voltage (V)" not in list(df) or "Current (A)" not in list(df):
            raise Exception("Invalid file data descriptors.")
        data = df.values.tolist()
        if "Power (W)" not in list(df):
            data = [[volt, curr, volt * curr] for volt, curr in data]
        return data

    def get_pos(self) -> list[list[int, int]]:
        """Get the position of the PV constituents.

        Returns:
            list[list[int, int]]: List of cell positions in PV.
        """
        raise NotImplementedError

    def get_voltage(
        self, current: float, irrad: list[float], temp: list[float]
    ) -> float:
        """Get the voltage generated by the PV as a function of the current
        applied through the PV and external environment and internal cell
        characteristics.

        Args:
            current (float): Current through PV. Amps.
            irrad (list[float]): Irradiance incident on PV. W/m^2.
            temp (list[float]): Surface temperature of PV. Kelvin.

        Returns:
            float: Voltage across PV. Volts.
        """
        raise NotImplementedError

    def get_current(
        self, voltage: float, irrad: list[float], temp: list[float]
    ) -> float:
        """Get the current generated by the PV as a function of the voltage
        applied across the PV and external environment and internal cell
        characteristics.

        Args:
            voltage (float): Voltage across PV. Volts.
            irrad (list[float]): Irradiance incident on PV. W/m^2.
            temp (list[float]): Surface temperature of PV. Kelvin.

        Returns:
            float: Current through PV. Amps.
        """
        raise NotImplementedError

    def get_iv(
        self,
        irrad: list[float],
        temp: list[float],
        curr_range: list[float] = [-10.0, 10.0],
        volt_range: list[float] = [-10.0, 10.0],
    ) -> list[list[float, float, float]]:
        """Get the I-V curve of the instance for some specific irradiance and
        temperature as an array of points.

        Args:
            irrad (list[float]): Irradiance incident on PV. W/m^2.
            temp (list[float]): Surface temperature of PV. Kelvin.
            curr_range (list[float]): Current bounds to capture.
            volt_range (list[float]): Voltage bounds to capture.

        Returns:
            list[list[float, float, float]]: List of ordered
                voltage-current-power triplets. Volts, Amps, Watts.
        """
        raise NotImplementedError

    def get_edge(
        self,
        irrad: list[float],
        temp: list[float],
        max_isc: float = 10.0,
        max_voc: float = 10.0,
    ) -> ((float, float), (float, float)):
        """Get the 1st power quadrant edge characteristics of the instance.

        Args:
            irrad (list[float]): Irradiance incident on PV. W/m^2.
            temp (list[float]): Surface temperature of PV. Kelvin.
            max_isc (float): Maximum expected 1st power quadrant ISC.
            max_voc (float): Maximum expected 1st power quadrant VOC.

        Returns:
            (float, float), (float, float):
                Open circuit voltage (Volts)
                Short circuit current (Amps)
                Maximum power point voltage (Volts)
                Maximum power point current (Amps)
        """
        iv = self.get_iv(irrad, temp, curr_range=[0, max_isc], volt_range=[0, max_voc])
        df = pd.DataFrame(iv, columns=["Voltage (V)", "Current (A)", "Power (W)"])
        df = df[df["Power (W)"] > 0.0]

        v_oc = df.nlargest(1, "Voltage (V)").iloc[0]["Voltage (V)"]
        i_sc = df.nlargest(1, "Current (A)").iloc[0]["Current (A)"]

        mpp = df.nlargest(1, "Power (W)")
        v_mpp = mpp.iloc[0]["Voltage (V)"]
        i_mpp = mpp.iloc[0]["Current (A)"]

        return (v_oc, i_sc), (v_mpp, i_mpp)

    def vis(
        self,
        irrad: list[float],
        temp: list[float],
        curr_range: list[float] = [-10.0, 10.0],
        volt_range: list[float] = [-10.0, 10.0],
        return_graph: bool = False,
        show_exp_data: bool = False,
    ) -> None | dict:
        """
        TODO: documentation, support for:
        - displaying experimental data
        - returning a widget
        - specifying a sweep across a set of external or internal parameters.
        - specifying multiple graphs
        - specifying bounds
        """

        # Create graphs
        data = self.get_iv(irrad, temp, curr_range, volt_range)
        data = np.transpose(data)

        # Populate graph
        graph = {
            "instance": Graph(
                "I-V/P-V Curve",
                "Voltage (V)",
                "Current/Power (A/W)",
            ),
            "title": "I-V/P-V Curve",
            "widget": None,
            "position": [0, 0],
        }
        graph["instance"].add_series(
            {
                "iv": {"x": data[0], "y": data[1], "color": (255, 0, 0, 255)},
                "pv": {"x": data[0], "y": data[2], "color": (0, 255, 0, 255)},
            },
            "scatter",
        )

        if show_exp_data and self._data:
            data = np.transpose(self._data)
            graph["instance"].add_series(
                {
                    "iv_exp": {"x": data[0], "y": data[1], "color": (255, 0, 255, 255)},
                    "pv_exp": {"x": data[0], "y": data[2], "color": (0, 255, 255, 255)},
                },
                "scatter",
            )

        graph["instance"].set_graph_range(volt_range, curr_range)

        if return_graph:
            return graph
        else:
            if not QtWidgets.QApplication.instance():
                app = QtWidgets.QApplication(sys.argv)
            else:
                app = QtWidgets.QApplication.instance()

            container = QtWidgets.QWidget()
            container_layout = QtWidgets.QGridLayout()
            container.setLayout(container_layout)

            graph["widget"] = graph["instance"].get_graph()
            container_layout.addWidget(graph["widget"], *graph["position"])

            win = QtWidgets.QMainWindow()
            win.setGeometry(0, 0, 720, 480)
            win.setWindowTitle(f"I-V/P-V Curve")
            win.setCentralWidget(container)

            win.show()
            exe = app.exec()

    def get_params(self) -> dict:
        """Get associated reference and curve fitting parameters associated with
        the PV.

        Returns:
            dict: Parameters.
        """
        return self._params

    def _fit_params(self, data, fitting_parameters, residual):
        """Fit model to the data and update the associated parameters.

        Args:
            data (_type_): _description_
            fitting_parameters (_type_): _description_
            residual (_type_): _description_

        Returns:
            _type_: _description_
        """
        optimizer_parameters = Parameters()
        for key, value in fitting_parameters.items():
            if value["given"]:
                optimizer_parameters.add(
                    key,
                    min=value["min"] / self.FIT_RESOLUTION,
                    value=value["val"] / self.FIT_RESOLUTION,
                    max=value["max"] / self.FIT_RESOLUTION,
                    vary=False,
                )
            else:
                optimizer_parameters.add(
                    key,
                    min=value["min"] / self.FIT_RESOLUTION,
                    value=value["stc"] / self.FIT_RESOLUTION,
                    max=value["max"] / self.FIT_RESOLUTION,
                    vary=True,
                )

        res = minimize(
            residual,
            optimizer_parameters,
            args=(data, self),
            method="powell",
        )
        print(fit_report(res))

        for key, value in fitting_parameters.items():
            value["val"] = res.params[key].value * self.FIT_RESOLUTION

        return fitting_parameters

    def fit_params(self, irradiance: float = None, temperature: float = None) -> dict:
        """Fit parameters relevant to the model and return their results.

        Args:
            irradiance (float, optional): Known irradiance if any. Defaults to None.
            temperature (float, optional): Known temperature if any. Defaults to None.

        Returns:
            dict: Dict of fitting parameters and determined values.
        """
        raise NotImplementedError
